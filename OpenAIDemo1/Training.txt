Read and analyze all the provided T-SQL batch and apply the following rules:

1. When you find a query such as “SELECT * FROM Expression”, read all the query, and identify which columns of that Expression are really used in the batch to build 
the output result or to modify some tables. Replace the “*” in the SELECT statement with only the columns you found as used. 
If reading the code below the “SELECT *” statement it is not possible to understand which columns are really used, don’t make any assumption 
and replace the * with all column’s names of the table. You have the list of columns of a table in JSON format.

2.When an ORDER BY is written using the column number (for example: ORDER BY 1, 3, 5) rewrite the ORDER BY clause with column names used in the SELECT clause to avoid any confusion.

3. If you have a SELECT query that uses implicit joins, meaning it lists multiple tables in the FROM clause and defines the join conditions in the WHERE clause, then rewrite it using explicit join syntax with ON, JOIN keyword and specify the join columns.
Ensure that all table relationships and filter conditions remain logically equivalent.

4.When you find WHERE expression containing functions on column such as: CEILING(column) = x, or FLOOR(column) = x, or ROUND(column) don't use any function on the column. Rewrite the WHERE expression leaving the column alone on left side of the comparison and rewrite an equivalent condition on x modifying the right side of the comparison. Apply the following rules:
a) "WHERE CEILING(UnitPrice) = 714" must be rewritten as "WHERE UnitPrice > 713 AND UnitPrice <= 714"
b) "WHERE FLOOR(UnitPrice) = 714" must be rewritten as "WHERE UnitPrice >= 714 AND UnitPrice < 715"
c) "WHERE ROUND(UnitPrice) = 714" must be rewritten as "WHERE UnitPrice BETWEEN 714 - 0.5 AND UnitPrice < 714 + 0.5"

5. If the provided code contains a WHERE condition with the SIGN() function applied to a column rewrite the query to avoid the function and make the condition SARGable. Apply the following rules:
a) "WHERE SIGN(SalesOrderID) = 1" must be rewritten as  "WHERE SalesOrderID > 0"
b) "WHERE SIGN(SalesOrderID) = -1" must be rewritten as "WHERE SalesOrderID < 0"
c) "WHERE SIGN(SalesOrderID) = 0" must be rewritten as "WHERE SalesOrderID = 0"

6. When the WHERE expression contains functions on column such as: ABS(column), SQRT(column) or POWER(column,2) having the column as parameter, rewrite the WHERE expression leaving the column alone on left side of the comparison and rewrite an equivalent condition modifying the right side of the comparison as shown in the following examples. Apply the following rules:
a) "WHERE ABS(level) < value”  must be rewritten as “WHERE level < value AND level > -value”
b) "WHERE SQRT(column) <  value" must be rewritten as: "WHERE column < POWER(value,2)"
c) "WHERE POWER(column,2) <  value" must be rewritten as: "WHERE column < SQRT(value)"

7. In a WHERE comparison clause, if there are calculations or transformations on a column, leave the column alone on left side and move the equivalent calculation on the right. 
On the left side of the comparison there should appear only the column without any operator applied. This ensures better performance, as it allows SQL Server to optimize index usage effectively. Apply the following rules:
a) avoid “WHERE price * 12 = 550“ replace with “WHERE price = 550/12”
b) avoid “WHERE price + 12 = 550“ replace with “WHERE price = 550-12”
c) avoid “WHERE price / 12 = 550“ replace with “WHERE price = 550*12”

8. If the WHERE condition is an equation-like expression, rewrite this T-SQL WHERE clause to make it SARGable by isolating the column on left side of the comparison. Apply the basic algebraic manipulation equation principles to isolate the column on left side. Verify that the rewritten condition has the same mathematical meaning.

9. When you find WHERE expression containing functions on column such as: DATEDIFF(column) or DATEADD(column) having the column as parameter, 
rewrite the WHERE expression leaving the column alone on left side of the comparison and rewrite an equivalent condition modifying the rigth side of the 
comparison as in the following examples:
a) “WHERE DATEDIFF(DAY, ModifiedDate, GETDATE()) < 21” must be rewrittes as “WHERE ModifiedDate >= DATEADD(DAY, -21, GETDATE())”.
b) “WHERE DATEADD(DAY, 30, ModifiedDate) >= ‘2024-01-01′” must be rewritten as “WHERE ModifiedDate >= DATEADD(DAY, -30, ‘2024-01-01’)”
c) "WHERE DATEPART(YEAR, ModifiedDate) = 2013" must be rewritten as "WHERE ModifiedDate >= '2013-01-01’ AND ModifiedDate < '2014-01-01'".

10. If in the WHERE clause the YEAR function is applied to a column, use range comparison according to the following examples:
YEAR(OrderDate) = 2022 → OrderDate >= ‘2022-01-01’ AND OrderDate < ‘2023-01-01’.

11. If the provided code contains a WHERE condition with UPPER() or LOWER() functions applied to a column, then then rewrite the query to avoid to apply the function to the column and make the condition SARGable. Apply the following rules:
a) WHERE UPPER(Name) = 'MARCO'  must be rewritten as:  WHERE Name = 'MARCO'
b) WHERE LOWER(Name) = 'marco'  must be rewritten as:  WHERE Name = 'marco'

12. If the provided code contains a WHERE condition with the ISNULL() function applied to a column rewrite the query to avoid the function and make the condition SARGable as in this example.
Example: 
WHERE ISNULL(ColumnX, <entity>) > 23  must be rewritten as:  WHERE (ColumnX > 23 OR ColumnX IS NULL AND <entity> > 23)

13. When you find WHERE conditions such as: WHERE column LIKE '%text’ or LIKE '%text%', act as follows:
a) If the string to search has ‘%’ at the beginning of the string to search, use the RIGHT function instead. For example replace: “WHERE AddressLine LIKE '%way'” with:  “WHERE RIGHT(AddressLine,3) = 'way'”
b) If the string to search is between two wildcards‘%’, use the PATINDEX function instead. For example replace: “WHERE AddressLine LIKE '%way%'” with:  “WHERE CHARINDEX('way', AddressLine, 0) > 0”
c) If the string to search has wildcard ‘%’ at the end of the string, don't modify this condition. For example: “WHERE AddressLine LIKE 'way%'”  don't modify that. 
d) If the WHERE condition contains both conditions: "column LIKE '%way'" AND "column LIKE 'way%'" then rewrite as "column = 'way'"

14. Analyze the provided code carefully to identify UNUSED elements such as parameters or variables or items that are declared in DECLARE statement and after such declaration they don't appear in the code anymore. Before you decide something is unused, check that if it's really not used after DECLARE declaration line. Identify again all unused items, and return the query rewritten by removing all unused items that you identified from the code. Unused items can be:
a) function or stored procedure parameters: drop them also from the function or stored procedure definition.
b) variables or table variables 
c) temporary tables created in the code

15. In a multi line function, check the entire flow of the SQL code from start to finish. Determine which elements do not contribute (redundant or irrelevant) to the final SELECT statement or to the returned value. Remove redundant or irrelevant items them from the body of the function. Irrelevant items can be the following:
a) function or stored procedure parameters. Drop them also from the function or stored procedure definition.
b) variables or table variables 
c) temporary tables created in the code
d) Irrelevant piece of code.

16. You have information about the data type of every column of every table, passed to you in JSON format.
In the original code, identify all WHERE conditions containing comparisons between column and variable, using operators such as: such as =, >, >=, <, or <=.
Determine the column’s data type based on the provided JSON data and identify the variable’s data type by analyzing the code. If the column and variable have different data types, either rewrite the WHERE condition applying the CONVERT() function to the variable to match the column’s data type or declare the variable with the same data type as the column. At the end, column and variable must have exactly the same data type.

17. You have information about the data type of every column of every table, passed to you in JSON format.
In the original code, identify all WHERE conditions containing comparisons between column and constants or literals, using operators such as: such as =, >, >=, <, or <=.
Determine the column’s data type based on the provided JSON data. If the column and constant have different data types, rewrite the WHERE condition converting the constant to match the column’s data type. The value compared to the column must always the same data type as the column.

18. Analize the provided code and identify dynamic SQL executions such as:  "EXEC @query" or "EXEC sp_executesql @query" without parameters. Identify only the cases with the command string @query is unvalidated AND it is built by concatenating multiple strings or variables. In this cases rewrite the code using one of the following two alternative options:
1. keep EXEC @query, and add to to the code additional check validations on sql string. Add the verification that the command string @query doesn't contain suspicious keywords "DROP", "DELETE", ";", "UPDATE". In addition report a warning comment in the modified code.
2. Replace EXEC with EXEC sp_executesql @query, passing parameters instead concatenating paramenters in the @query command string.
3. If the argument of EXEC function is a fixed query not built concatenating any variable, just remove exec and execute the argument statement.